### objcopy和objdump

[Linux-GNU-C-Chater5-1.1-6(objcopy+objdump)]( https://www.bilibili.com/video/BV1mT411T78E/?share_source=copy_web&vd_source=bad63bc206890ec49ce3dba8cc7b7a37)



片上系统（CoS）、物理地址的划分



## lab7-2实现原理





```c
ld --verbose
```



### 链接器脚本文件简介

在链接器脚本文件中描述了程序不同的段在内存中的分布情况，比如下面这份链接器脚本文件：

```C++
```



![image-20240321111720553](images/image-20240321111720553.png)





### elf的program talbe和C++实际的内存地址空间布局是对应的吗？加载的过程中是如何完成的



### 观察课程代码中extern 的用法

### 内存对齐的实现

[课程代码](https://github.com/try-agaaain/riscv-operating-system-mooc/blob/4698c95063d50428a7c11b289e8b4c1c213810f0/code/os/02-memanagement/page.c#L73-L77) 中通过下面的函数实现内存对齐。

```c
#define PAGE_SIZE 4096
#define PAGE_ORDER 12

static inline uint32_t _align_page(uint32_t address)
{
        uint32_t order = (1 << PAGE_ORDER) - 1;
        return (address + order) & (~order);
}
```

通过GPT了解了它的工作原理：

>`1 << PAGE_ORDER` 是将 1 左移 PAGE_ORDER（12）个位，结果是页大小（4096），再减去 1 得到一个除页大小最高位之外所有位都是 1 的数字（即 4095，二进制为 111111111111）。
>
>`address + order` 将输入地址加上4095，这样做的目的是让地址上加上一个可能会超出当前页面的值。
>
>`~order` 对 4095 取反，得到一个所有位都是 0，除了最高 12 位以外。这是一个所有低位都是 0 的掩码，用于页面对齐。
>
>`& (~order)` 然后将上述相加的结果和掩码进行按位与操作，除去低位中的所有 1，从而实现对齐。这一步确保了返回的地址会是 4096 的倍数，即页面对齐的地址。

这就像是 (8435 + 100-1) // 100 = 8500，得到的结果与100对齐。



## lab8 malloc和free实现细节

### Page 级别的内存分配和释放

首先由链接器根据链接器脚本文件确定好程序各个段的内存地址，随后计算出剩余内存空间的开始地址和结束地址作为堆的分配空间；

![image-20240321170813250](images/image-20240321170813250.png)

为便于管理堆区，将堆以页为单位进行划分（每个页的大小为`PAGE_SIZE=4096`），假设堆的起始内存地址为`HEAP_START`，将其前8个页用于存储每个页的索引信息，用户申请的内存地址从第9个页开始（地址为`_alloc_start`），索引的数据结构如下：

```c
struct Page {
	uint8_t flags;
};
```

每个page占8个比特，其中低二位可分别用作标记：①是否已被分配`PAGE_TAKEN`；②是否为连续页的最后一页`PAGE_LAST`（连续页的释放时会用到）。

当用户申请分配`k`个页时：

①先从`HEAP_START`对应的第0个索引开始依次遍历索引数组，找到未被分配且大小合适的连续页，假设第一个页的索引号为`i`，将与其连续的`k`个索引标记为`PAGE_TAKEN`，并将第`i+k`个索引标记为连续页`PAGE_LAST`；

②通过`_alloc_start`计算出第`i`个页的内存地址，并将其返回给用户。

此时内存结构可以用下图表示：

![image-20240321195147499](images/image-20240321195147499.png)

### 字节级别的内存管理：malloc和free

在page管理的基础上，采用链表的方式申请字节级别的内存空间，其过程如下：

①申请一个页作为初始的